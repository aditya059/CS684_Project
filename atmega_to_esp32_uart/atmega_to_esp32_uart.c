// /*
// TITLE	: UART Communication: ATmega 2560 & ESP32
// DATE	: 2019/11/12
// AUTHOR	: e-Yantra Team

// AIM: To send data on UART#0 of ATMega 2560 to ESP32
// */


#define F_CPU 14745600		// Define Crystal Frequency of eYFi-Mega Board
#include <avr/io.h>				// Standard AVR IO Library
#include <util/delay.h>			// Standard AVR Delay Library
#include <avr/interrupt.h>		// Standard AVR Interrupt Library
#include "uart.h"				// Third Party UART Library

#include <ctype.h>
#include <string.h>
#include <stdio.h>

#include <stdlib.h>
#include "lcd.h"

#define PIN_LED_GREEN	PH5		// Macro for Pin Number of Green Led
#define MESSAGE			"Tx from ATmega 2560> Hello ESP32!\n" // Message to be sent on UART #0

// #define UART2_STATUS   UCSR2A
// #define UART2_CONTROL  UCSR2B
// #define UART2_DATA     UDR2
// #define UART2_UDRIE    UDRIE2  
// #define UART2_RECEIVE_INTERRUPT   USART2_RX_vect
// #define UART_RX2_BUFFER_MASK (UART_RX2_BUFFER_SIZE - 1)

// static volatile uint8_t UART2_TxBuf[UART_TX2_BUFFER_SIZE];
// static volatile uint8_t UART2_RxBuf[UART_RX2_BUFFER_SIZE];

// static volatile uint16_t UART2_TxHead;
// static volatile uint16_t UART2_TxTail;
// static volatile uint16_t UART2_RxHead;
// static volatile uint16_t UART2_RxTail;
// static volatile uint8_t UART2_LastRxError;

volatile unsigned int count = 0;	// Used in ISR of Timer2 to store ms elasped
unsigned int seconds = 0;			// Stores seconds elasped
char rx_byte;
char lcd_array[100];
int idx = 0;

// structs to store request states
struct scan_req {
	int plot, id, serverTime, completeIn;
};

struct fetch_req {
	int id, serverTime, completeIn;
};

struct scan_resp {
	int id, plot, timeTaken;
};

struct fetch_resp {
	int id, timeTaken;
	char *type;
};



volatile unsigned long int pulse = 0; //to keep the track of the number of pulses generated by the color sensor
volatile unsigned long int red;       // variable to store the pulse count when read_red function is called
volatile unsigned long int blue;      // variable to store the pulse count when read_blue function is called
volatile unsigned long int green;     // variable to store the pulse count when read_green function is called

// void lcd_port_config (void)
// {
// 	DDRC = DDRC | 0xF7; //setting all the LCD pin's direction set as output
// 	PORTC = PORTC & 0x80; //setting all the LCD pins are set to logic 0 except PORTC 7
// }

void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
	PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
}

void port_init(void)
{
	// lcd_port_config();//lcd pin configuration
	color_sensor_pin_config();//color sensor pin configuration
}

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
	sei(); // Enables the global interrupt
}

//ISR for color sensor
ISR(INT0_vect)
{
	pulse++; //increment on receiving pulse from the color sensor
}

void init_devices(void)
{
	cli(); //Clears the global interrupt
	port_init();  //Initializes all the ports
	color_sensor_pin_interrupt_init();
	sei();   // Enables the global interrupt
}

//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
	PORTD = PORTD & 0x7F; //set S3 low
}

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
	PORTD = PORTD | 0x80; //set S3 High
}

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
	PORTD = PORTD | 0x80; //set S3 High
}

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	PORTD = PORTD | 0x40; //set S2 High
	PORTD = PORTD & 0x7F; //set S3 Low
}

//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
}

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
	
	lcd_cursor(1,1);  //set the cursor on row 1, column 1
	lcd_string(0, 0, "Red Pulses"); // Display "Red Pulses" on LCD
	lcd_numeric_value(2,1,red,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	lcd_wr_command(0x01); //Clear the LCD
}

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
	
	lcd_cursor(1,1);  //set the cursor on row 1, column 1
	lcd_string(0, 0, "Green Pulses"); // Display "Green Pulses" on LCD
	lcd_numeric_value(2,1,green,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	lcd_wr_command(0x01); //Clear the LCD
}

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
	
	lcd_cursor(1,1);  //set the cursor on row 1, column 1
	lcd_string(0, 0, "Blue Pulses"); // Display "Blue Pulses" on LCD
	lcd_numeric_value(2,1,blue,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	lcd_wr_command(0x01); //Clear the LCD
}



void init_timer2(void){
	cli();	// Turn off global interrupts

	//Setup Timer2 to fire every 1ms
	TCCR2B = 0x00;        						// Cut off Clock Source to disbale Timer2 while we set it up
	TCNT2  = 130;         						// Reset Timer Count to 130 out of 255
	TIFR2  &= ~(1 << TOV2);        				// Timer2 INT Flag Reg: Clear Timer Overflow Flag
	TIMSK2 |= (1 << TOIE2);        				// Timer2 INT Reg: Timer2 Overflow Interrupt Enable
	TCCR2A = 0x00;        						// Timer2 Control Reg A: Wave Gen Mode normal
	TCCR2B |= (1 << CS22) | (1 << CS20);        // Timer2 Control Reg B: Timer Prescaler set to 128 and Start Timer2

	sei();	// Turn on global interrupts
}

char uart2_readByte(void){

	uint16_t rx;
	uint8_t rx_status, rx_data;

	rx = uart2_getc();
	rx_status = (uint8_t)(rx >> 8);
	rx = rx << 8;
	rx_data = (uint8_t)(rx >> 8);

	if(rx_status == 0 && rx_data != 0){
		return rx_data;
	} else {
		return -1;
	}

}

//Timer2 Overflow Interrupt Vector
ISR(TIMER2_OVF_vect) {
  count++;	// increment after 1 ms               
  
  // increment seconds variable after 1000 ms
  if(count > 999){
	seconds++;
	
	// uart2_puts(MESSAGE);	    // Send data on UART #0 after 1 second

    count = 0;          
  }
  
  TCNT2 = 130;           	// Reset Timer to 130 out of 255
  TIFR2  &= ~(1 << TOV2);	// Timer2 INT Flag Reg: Clear Timer Overflow Flag
};

// ISR(UART2_RECEIVE_INTERRUPT)
// /*************************************************************************
// Function: UART2 Receive Complete interrupt
// Purpose:  called when the UART2 has received a character
// **************************************************************************/
// {
// 	uint16_t tmphead;
// 	uint8_t data;
// 	uint8_t usr;
// 	uint8_t lastRxError;


// 	/* read UART status register and UART data register */
// 	usr  = UART2_STATUS;
// 	data = UART2_DATA;

// 	/* */
// 	lastRxError = (usr & (_BV(FE2)|_BV(DOR2)));

// 	/* calculate buffer index */
// 	tmphead = (UART2_RxHead + 1) & UART_RX2_BUFFER_MASK;

// 	if (tmphead == UART2_RxTail) {
// 		/* error: receive buffer overflow */
// 		lastRxError = UART_BUFFER_OVERFLOW >> 8;
// 	} else {
// 		/* store new index */
// 		UART2_RxHead = tmphead;
// 		/* store received data in buffer */
// 		UART2_RxBuf[tmphead] = data;
// 	}
// 	UART2_LastRxError = lastRxError;
// }


// ISR(USART2_RX_vect)
// {
// 	// uart2_puts("Qwertyuiop");
// 	rx_byte = uart2_readByte();
// 	// if(rx_byte == -1) {
// 	// 	lcd_string(0, 0, "gand maro");
// 	// }
// 	if(isalnum(rx_byte)) {
// 			// lcd_clear();
// 			// lcd_string(0, 0, "receiving...");
// 		//	uart2_putc(rx_byte);
// 		// 	led_greenOn();
// 		if(idx < 100)
// 			lcd_array[idx++] = rx_byte;
// 	}
// 	//		lcd_string(0, 0, lcd_array);
// 	if(rx_byte == '-') {
// 		idx = 0;
// 		if(lcd_array[0]=='s') {
// 			lcd_clear();
// 			lcd_string(0, 0, "scan");

// 			// struct scan_req *req_info = malloc(sizeof(struct scan_req));
// 			// char *curr = strtok(lcd_array, " ");
// 			// int curr_int;
// 			// sscanf(curr, &curr_int);
// 			// req_info->plot = curr_int;
// 			// curr = strtok(NULL, " ");
// 			// sscanf(curr, &curr_int);
// 			// req_info->id = curr_int;
// 			// curr = strtok(NULL, " ");
// 			// sscanf(curr, &curr_int);
// 			// req_info->serverTime = curr_int;
// 			// curr = strtok(NULL, " ");
// 			// sscanf(curr, &curr_int);
// 			// req_info->completeIn = curr_int;
			
// 			// struct scan_resp *resp_info = malloc(sizeof(struct scan_resp));
// 			// pass req_info and resp_info to the motion function
// 			// _delay_ms(5000);
// 			// resp_info->id = 100;
// 			// resp_info->plot = 13;
// 			// resp_info->timeTaken = 30;
// 			// char resp_vals[100];
// 			// sprintf(resp_vals, "%d %d %d", resp_info->id, resp_info->plot, resp_info->timeTaken);
// 			uart2_puts("resp_vals");
// 			// lcd_clear();
// 			// lcd_string(0, 0, resp_vals);
// 			// free(req_info);
// 			// free(resp_info);
// 		}
// 		else if(lcd_array[0]=='f') {
// 			lcd_clear();
// 			lcd_string(0, 0, "fetch");
// 		}		
// 	}	
// }


void init_led(void){
	DDRH    |= (1 << PIN_LED_GREEN);    
	PORTH   |= (1 << PIN_LED_GREEN);    
}

void led_greenOn(void){
	PORTH &= ~(1 << PIN_LED_GREEN);

}

void led_greenOff(void){
	PORTH |= (1 << PIN_LED_GREEN);
}

void read_color_sensor() {
	red_read(); //display the pulse count when red filter is selected
	// _delay_ms(100);
	// green_read(); //display the pulse count when green filter is selected
	// _delay_ms(100);
	// blue_read(); //display the pulse count when blue filter is selected
	// _delay_ms(100); 
}

int main(void) {
	lcd_port_config();					// Initialize the LCD port
	lcd_init();							// Initialize the LCD	

	init_led();
	init_timer2();

	uart2_init(UART_BAUD_SELECT(115200, F_CPU));
	uart2_flush();

    init_devices();
    lcd_set_4bit();
	color_sensor_scaling();

	lcd_string(0, 0, "uart2+color");

	while(1) {
		// read_color_sensor();
		// uart2_puts("Qwertyuiop");
		rx_byte = uart2_readByte();
		// lcd_string(0, 0, &rx_byte);
		if(isalnum(rx_byte)) {
				// lcd_clear();
				// lcd_string(0, 0, "receiving...");
				//	uart2_putc(rx_byte);
				// 	led_greenOn();
			if(idx < 100)
				lcd_array[idx++] = rx_byte;
		}
		//		lcd_string(0, 0, lcd_array);
		if(rx_byte == '-') {
			idx = 0;
			if(lcd_array[0]=='s') {
				lcd_clear();
				lcd_string(0, 0, "scan");
				_delay_ms(500);
				lcd_clear();
				read_color_sensor();
				// struct scan_req *req_info = malloc(sizeof(struct scan_req));
				// char *curr = strtok(lcd_array, " ");
				// int curr_int;
				// sscanf(curr, &curr_int);
				// req_info->plot = curr_int;
				// curr = strtok(NULL, " ");
				// sscanf(curr, &curr_int);
				// req_info->id = curr_int;
				// curr = strtok(NULL, " ");
				// sscanf(curr, &curr_int);
				// req_info->serverTime = curr_int;
				// curr = strtok(NULL, " ");
				// sscanf(curr, &curr_int);
				// req_info->completeIn = curr_int;
				
				// struct scan_resp *resp_info = malloc(sizeof(struct scan_resp));
				// pass req_info and resp_info to the motion function
				// _delay_ms(5000);
				// resp_info->id = 100;
				// resp_info->plot = 13;
				// resp_info->timeTaken = 30;
				// char resp_vals[100];
				// sprintf(resp_vals, "%d %d %d", resp_info->id, resp_info->plot, resp_info->timeTaken);
				uart2_puts(MESSAGE);
				// lcd_clear();
				// lcd_string(0, 0, resp_vals);
				// free(req_info);
				// free(resp_info);
			}
			else if(lcd_array[0]=='f') {
				lcd_clear();
				lcd_string(0, 0, "fetch");
			}
		}	
	}

	return 0;	
}
